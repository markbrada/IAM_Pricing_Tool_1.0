<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>InAMinnit Pricing Sheet</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 1rem;
    }
    #sheetButtons > button {
      margin-right: 0.5rem;
    }
    /* Container for search box + table */
    .sheet-view {
      margin-bottom: 2rem;
    }
    table {
      border-collapse: collapse;
      margin-top: 0.5rem;
    }
    td, th {
      border: 1px solid #aaa;
      padding: 0.5rem;
      cursor: default;
    }
    td:active {
      background-color: #f2f2f2; /* Quick visual feedback on click */
    }
    .header-cell {
      background-color: #d3d3d3; /* Light grey background for header */
      font-weight: bold;
    }
    .search-label {
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>

<h2>InAMinnit Pricing Sheet</h2>
<p>Early Alpha version - only for test purposes</p>

<div id="sheetButtons"></div>
<!-- This container will be cleared and populated each time you switch tabs -->
<div id="sheetContainer"></div>

<!-- Include SheetJS library (xlsx.full.min.js) -->
<script src="xlsx.full.min.js"></script>
<script>
// Columns that should be displayed with two decimals
const PRICE_COLUMNS = [
  "Rate Ex. GST",
  "Price Ex. GST",
  "Price Inc. GST"
];

const sheetButtons = document.getElementById("sheetButtons");
const sheetContainer = document.getElementById("sheetContainer");

// 1) Fetch the Excel file automatically (no file upload)
fetch("myFile.xlsx")
  .then(response => response.arrayBuffer())
  .then(data => {
    // Parse the workbook with SheetJS
    const workbook = XLSX.read(data, { type: "array" });

    // Create a button for each sheet
    Object.keys(workbook.Sheets).forEach(sheetName => {
      const btn = document.createElement("button");
      btn.textContent = sheetName;
      btn.onclick = () => showSheet(workbook, sheetName);
      sheetButtons.appendChild(btn);
    });

    // Optionally, auto-display the first sheet:
    // if (Object.keys(workbook.Sheets).length > 0) {
    //   showSheet(workbook, Object.keys(workbook.Sheets)[0]);
    // }
  })
  .catch(err => {
    console.error("Failed to fetch Excel file:", err);
    sheetContainer.textContent = "Error fetching Excel file.";
  });

// 2) Show the chosen sheet with a search box
function showSheet(workbook, sheetName) {
  const sheet = workbook.Sheets[sheetName];

  // Convert to 2D array, preserving blanks
  const rows = XLSX.utils.sheet_to_json(sheet, {
    header: 1,
    defval: "",
    blankrows: true
  });

  // Ensure each row has the same number of columns
  const maxCols = Math.max(...rows.map(r => r.length));
  rows.forEach(row => {
    while (row.length < maxCols) {
      row.push("");
    }
  });

  // Clear the sheetContainer and build a wrapper
  sheetContainer.innerHTML = "";
  const wrapper = document.createElement("div");
  wrapper.classList.add("sheet-view");
  sheetContainer.appendChild(wrapper);

  // Create a search label and input
  const searchLabel = document.createElement("label");
  searchLabel.textContent = "Search items:";
  searchLabel.classList.add("search-label");

  const searchInput = document.createElement("input");
  searchInput.type = "text";
  searchInput.placeholder = "Type to filter...";

  // Put label + input at the top of wrapper
  wrapper.appendChild(searchLabel);
  wrapper.appendChild(searchInput);

  // Create a container for the table
  const tableContainer = document.createElement("div");
  wrapper.appendChild(tableContainer);

  // The first row is typically headers
  let headers = rows.length > 0 ? rows[0].map(h => String(h).trim()) : [];

  // Function to build or rebuild the table from a given set of rows
  function buildTable(filteredRows) {
    // Clear the container
    tableContainer.innerHTML = "";
    // Create a table element
    const table = document.createElement("table");

    filteredRows.forEach((row, rowIndex) => {
      const tr = document.createElement("tr");
      
      row.forEach((cellValue, colIndex) => {
        const td = document.createElement("td");

        // If this is the top row in the filtered set (rowIndex === 0 in the FULL data),
        // mark as header
        if (rowIndex === 0) {
          td.classList.add("header-cell");
        }

        let displayText = cellValue;
        // If not header row in the FULL data, check if column name is a "price" column
        if (rowIndex > 0 && headers[colIndex]) {
          const colHeader = headers[colIndex];
          if (PRICE_COLUMNS.includes(colHeader)) {
            // Attempt to round
            const parsedNum = parseFloat(cellValue);
            if (!isNaN(parsedNum)) {
              displayText = parsedNum.toFixed(2);
            }
          }
        }

        td.textContent = displayText;

        // Click: copy the displayed text
        td.onclick = () => {
          navigator.clipboard.writeText(displayText)
            .then(() => {
              console.log("Copied:", displayText);
            })
            .catch(err => {
              console.error("Clipboard error:", err);
            });
        };

        tr.appendChild(td);
      });

      table.appendChild(tr);
    });

    tableContainer.appendChild(table);
  }

  // Build table the first time (show all rows)
  buildTable(rows);

  // Listen for changes in the search box to filter rows
  searchInput.addEventListener("input", () => {
    const filterValue = searchInput.value.trim().toLowerCase();

    // If nothing typed, show all rows
    if (!filterValue) {
      buildTable(rows);
      return;
    }

    // Filter out rows that don't contain filterValue
    // Keep row[0] (the header row) regardless of match
    const filtered = rows.filter((row, index) => {
      if (index === 0) return true; // keep header row
      // Check if ANY cell in the row includes the filterValue
      return row.some(cell => String(cell).toLowerCase().includes(filterValue));
    });

    buildTable(filtered);
  });
}
</script>
</body>
</html>